-- Gradient computation from AD transformation, after fusion
-- Some expression simplifications that LLVM would perform anyway, are applied by hand.

let
  a0 = use (Matrix (Z :. 1 :. 3)    [ 7.9, 3.9, -7.5])
  a1 = use
         (Matrix (Z :. 4 :. 3)
           [ 0.0, 0.0, 1.0,
             0.0, 1.0, 1.0,
             1.0, 0.0, 1.0,
             1.0, 1.0, 1.0])
  a2 = generate
         (let T3 x0 x1 x2 = indexFull
                              (T3 (let T2 x0 _ = shape a0 in x0) () ())
                              (shape a1)
              T3 x3 x4 x5 = indexFull
                              (T3 () (let T2 x3 _ = shape a1 in x3) ())
                              (shape a0)
          in T3 (min x3 x0) (min x4 x1) (min x5 x2))
         (\(T3 x0 x1 x2) ->
            let x3 = a0 ! T2 x0 x2
                x4 = a1 ! T1 x1 x2
                x5 = x3 * x4
            in (x5, T3 x3 x4 x5))
  a3 = map (\(x0, _) -> x0) a2
  a4 = map
         (\x0 -> let x1 = -x0
                     x2 = exp x1
                     x3 = 1.0 + x2
                     x4 = 1.0 / x3
                 in (x4, T6 1.0 x0 x1 x2 x3 x4))
         (fold (+) 0.0 a3)
  a5 = map (\(x0, _) -> x0) a4
  a6 =
    let a6 = use (Matrix (Z :. 4 :. 1)    [ 0.0,     1.0,     1.0,     0.0])
    in
    generate
      (let T2 x0 x1 = shape a5
           T2 x2 x3 = shape a6
       in T2 (min x2 x1) (min x3 x0))
      (\(T2 x0 x1) ->
          let x2 = a6 ! (T2 x0 x1)
              x3 = a5 ! (T2 x1 x0)
              x4 = x2 - x3
          in (x4, T3 x2 x3 x4))
  a7 = map (\x0 -> let x1 = x0 * x0 in (x1, T2 x0 x1))
           (map (\(x0, _) -> x0) a6)
  a8 = map (\(x0, _) -> x0) a7
  a9 = reshape (shapeSize (shape a8)) a8
  a10 = use (Scalar Z [1.0])
  a11 = map (\(_, T2 x0 x1) -> T2 x0 x1) a7
  a12 = map (\(_, T3 x0 x1 x2) -> T3 x0 x1 x2) a6
  a13 = permute (+)
          (generate (shape a5) (\_ -> 0.0))
          (\(T2 x0 x1) -> (1, (T2 x1 x0)))
          (delayed
            (let T2 x0 x1 = shape a11
                 T2 x2 x3 = shape a8
                 T2 x4 x5 = shape a12
             in T2 (min (min x2 x0) x4) (min (min x3 x1) x5))
            (\(T2 x0 x1) ->
               let x3 = a10 ! ()
                   T2 x4 _ = a11 ! (T2 x0 x1)
               in -(x3 * x4 + x3 * x4)))
  a14 = map (\(_, T6 x0 x1 x2 x3 x4 x5) -> T6 x0 x1 x2 x3 x4 x5) a4
  a15 = map (\(_, T3 x0 x1 x2) -> T3 x0 x1 x2) a2
in
fold1 (+)
  (delayed
    (let T3 x0 x1 x2 = shape a15
         T3 x3 x4 x5 = shape a3
     in T3 (min x3 x0) (min x5 x2) (min x4 x1))
    (\(T3 x0 x1 x2) ->
       let T6 x3 _ _ x4 x5 _ = a14 ! (T2 x0 x2)
           x6 = -a13 ! (T2 x0 x2) * ((-x3) / (x5 * x5)) * x4
           T3 _ x7 _ = a15 ! (T3 x0 x2 x1)
       in x6 * x7))

-- vim: set ft=haskell:
